{"version":3,"file":"FluidGradientBackground-BAPA0WfH.js","sources":["../../src/hooks/useFluidGradient.ts","../../src/components/FluidGradientBackground.tsx"],"sourcesContent":["import { useEffect, useState, useCallback, useRef, useMemo, useLayoutEffect } from 'react';\n\ninterface SectionConfig {\n  id: string;\n  className: string;\n  threshold: number;\n  element?: HTMLElement | null;\n  top?: number;\n  height?: number;\n  isInView?: boolean;\n}\n\n// Memoizar a configuração das seções para evitar recriação\nconst SECTIONS: SectionConfig[] = [\n  { id: 'perfil', className: 'section-profile', threshold: 0.3 },\n  { id: 'projetos', className: 'section-projects', threshold: 0.3 },\n  { id: 'backlog', className: 'section-backlog', threshold: 0.3 },\n  { id: 'contato', className: 'section-contact', threshold: 0.3 },\n];\n\n// Cache para elementos de seção\nconst sectionElementsCache = new Map<string, HTMLElement | null>();\n\n// Função de debounce para otimizar eventos de scroll\nconst debounce = <F extends (...args: any[]) => any>(\n  func: F,\n  wait: number\n): ((...args: Parameters<F>) => void) => {\n  let timeout: ReturnType<typeof setTimeout> | null = null;\n  return (...args: Parameters<F>) => {\n    if (timeout) clearTimeout(timeout);\n    timeout = setTimeout(() => func(...args), wait);\n  };\n};\n\nexport const useFluidGradient = () => {\n  const [currentSection, setCurrentSection] = useState<string>('section-profile');\n  const sectionsRef = useRef<SectionConfig[]>([]);\n  const rafId = useRef<number | null>(null);\n  const lastScrollY = useRef(window.scrollY);\n  const ticking = useRef(false);\n  const lastSectionChange = useRef<number>(0);\n  const sectionChangeCooldown = 300; // ms de cooldown entre mudanças de seção\n\n  // Usar useLayoutEffect para sincronização síncrona do layout\n  useLayoutEffect(() => {\n    // Função para obter elementos com cache\n    const getSectionElement = (id: string): HTMLElement | null => {\n      if (sectionElementsCache.has(id)) {\n        return sectionElementsCache.get(id) || null;\n      }\n      const element = document.getElementById(id);\n      sectionElementsCache.set(id, element);\n      return element;\n    };\n\n    // Inicializar seções com elementos em cache\n    sectionsRef.current = SECTIONS.map(section => ({\n      ...section,\n      element: getSectionElement(section.id),\n      top: 0,\n      height: 0\n    }));\n    \n    // Atualizar dimensões iniciais com requestIdleCallback se disponível\n    const updateDims = () => {\n      if ('requestIdleCallback' in window) {\n        (window as any).requestIdleCallback(updateSectionDimensions, { timeout: 500 });\n      } else {\n        updateSectionDimensions();\n      }\n    };\n    \n    updateDims();\n    \n    // Otimizar o manipulador de redimensionamento\n    let resizeTimeout: ReturnType<typeof setTimeout>;\n    const handleResize = () => {\n      // Limpar timeout anterior\n      if (resizeTimeout) clearTimeout(resizeTimeout);\n      \n      // Usar um timeout para agrupar múltiplos eventos de redimensionamento\n      resizeTimeout = setTimeout(() => {\n        updateDims();\n        // Limpar cache de elementos em caso de redimensionamento\n        sectionElementsCache.clear();\n      }, 150);\n    };\n    \n    // Usar o manipulador de redimensionamento passivo para melhor desempenho\n    window.addEventListener('resize', handleResize, { passive: true });\n    \n    return () => {\n      window.removeEventListener('resize', handleResize);\n      if (resizeTimeout) clearTimeout(resizeTimeout);\n      if (rafId.current) {\n        cancelAnimationFrame(rafId.current);\n      }\n    };\n  }, []);\n\n  // Atualizar dimensões das seções de forma otimizada com batelamento\n  const updateSectionDimensions = useCallback(() => {\n    if (typeof window === 'undefined' || !sectionsRef.current.length) return;\n    \n    // Usar requestAnimationFrame para agrupar leituras de layout\n    if (rafId.current) {\n      cancelAnimationFrame(rafId.current);\n    }\n    \n    rafId.current = requestAnimationFrame(() => {\n      // Usar um elemento temporário para forçar sincronização de layout\n      const tempDiv = document.createElement('div');\n      tempDiv.style.position = 'fixed';\n      tempDiv.style.visibility = 'hidden';\n      document.body.appendChild(tempDiv);\n      tempDiv.offsetHeight; // Forçar reflow\n      \n      // Obter todas as medidas necessárias em um único frame\n      const scrollY = window.scrollY;\n      const viewportHeight = window.innerHeight;\n      \n      // Usar um array temporário para armazenar as novas seções\n      const newSections: SectionConfig[] = [];\n      let hasChanges = false;\n      \n      sectionsRef.current.forEach(section => {\n        // Usar o cache de elementos\n        const element = sectionElementsCache.get(section.id) || document.getElementById(section.id);\n        if (!element) {\n          newSections.push(section);\n          return;\n        }\n        \n        // Armazenar em cache\n        if (!sectionElementsCache.has(section.id)) {\n          sectionElementsCache.set(section.id, element);\n        }\n        \n        // Usar getBoundingClientRect uma única vez\n        const rect = element.getBoundingClientRect();\n        const top = rect.top + scrollY;\n        const height = rect.height;\n        const isInView = (\n          rect.top <= viewportHeight * 0.8 && \n          rect.bottom >= viewportHeight * 0.2\n        );\n        \n        // Verificar se houve mudanças significativas\n        if (\n          Math.abs((section.top || 0) - top) > 5 ||\n          Math.abs((section.height || 0) - height) > 5 ||\n          section.element !== element\n        ) {\n          hasChanges = true;\n          newSections.push({\n            ...section,\n            element,\n            top,\n            height,\n            isInView\n          });\n        } else {\n          newSections.push(section);\n        }\n      });\n      \n      // Atualizar as seções apenas se houver mudanças\n      if (hasChanges) {\n        sectionsRef.current = newSections;\n      }\n      \n      // Limpar o elemento temporário\n      document.body.removeChild(tempDiv);\n    });\n  }, []);\n\n  // Detectar seção ativa de forma otimizada com throttle e cooldown\n  const detectActiveSection = useCallback(() => {\n    if (typeof window === 'undefined') return 'section-profile';\n    \n    // Aplicar cooldown para evitar mudanças muito rápidas\n    const now = Date.now();\n    if (now - lastSectionChange.current < sectionChangeCooldown) {\n      return currentSection;\n    }\n    \n    const scrollY = window.scrollY;\n    const windowHeight = window.innerHeight;\n    \n    // Se não houve scroll significativo, não recalcular\n    if (Math.abs(scrollY - lastScrollY.current) < windowHeight * 0.1) {\n      return currentSection;\n    }\n    \n    // Atualizar cache da posição do scroll\n    lastScrollY.current = scrollY;\n    \n    // Se estiver no topo da página, sempre mostrar perfil\n    if (scrollY < windowHeight * 0.2) {\n      return 'section-profile';\n    }\n    \n    // Usar Intersection Observer se disponível para melhor performance\n    if ('IntersectionObserver' in window) {\n      const viewportMiddle = window.innerHeight / 2;\n      const elementAtCenter = document.elementFromPoint(\n        window.innerWidth / 2, \n        viewportMiddle\n      );\n      \n      if (elementAtCenter) {\n        const sectionElement = elementAtCenter.closest('[data-section]') as HTMLElement;\n        if (sectionElement?.dataset?.section) {\n          const sectionId = sectionElement.dataset.section;\n          const section = SECTIONS.find(s => s.id === sectionId);\n          if (section) {\n            lastSectionChange.current = now;\n            return section.className;\n          }\n        }\n      }\n    }\n    \n    // Fallback para cálculo manual se o IntersectionObserver não estiver disponível\n    let closestSection = currentSection;\n    let minDistance = Infinity;\n    \n    for (const section of sectionsRef.current) {\n      if (!section.element) continue;\n      \n      const elementCenter = (section.top || 0) + ((section.height || 0) / 2);\n      const viewportCenter = scrollY + (windowHeight / 2);\n      const distance = Math.abs(elementCenter - viewportCenter);\n      \n      if (distance < minDistance) {\n        minDistance = distance;\n        closestSection = section.className;\n      }\n    }\n    \n    if (closestSection !== currentSection) {\n      lastSectionChange.current = now;\n    }\n    \n    return closestSection;\n  }, [currentSection]);\n\n  // Gerenciador de scroll otimizado com throttle\n  const handleScroll = useCallback(() => {\n    if (!ticking.current) {\n      ticking.current = true;\n      \n      const frameId = requestAnimationFrame(() => {\n        const newSection = detectActiveSection();\n        if (newSection !== currentSection) {\n          // Usar requestAnimationFrame para agrupar atualizações de estado\n          requestAnimationFrame(() => {\n            setCurrentSection(newSection);\n            // Forçar sincronização de layout para evitar repaints desnecessários\n            document.body.getBoundingClientRect();\n          });\n        }\n        ticking.current = false;\n      });\n      \n      // Armazenar o ID do frame para possível cancelamento\n      rafId.current = frameId;\n    }\n  }, [currentSection, detectActiveSection]);\n\n  // Aplicar classe ao container de gradiente de forma otimizada\n  const applyGradientClass = useCallback((sectionClass: string) => {\n    const container = document.querySelector('.fluid-gradient-container');\n    if (!container) return;\n\n    // Usar requestAnimationFrame para agrupar as mudanças de classe\n    if (rafId.current) {\n      cancelAnimationFrame(rafId.current);\n    }\n    \n    const frameId = requestAnimationFrame(() => {\n      // Usar classList.toggle com force para melhor performance\n      // e evitar repaints desnecessários\n      const classList = container.classList;\n      let needsUpdate = false;\n      \n      // Verificar se a classe atual já está aplicada\n      const currentActive = SECTIONS.find(s => classList.contains(s.className));\n      if (currentActive?.className === sectionClass) return;\n      \n      // Usar um DocumentFragment para manipulação em lote\n      const tempDiv = document.createElement('div');\n      tempDiv.style.position = 'fixed';\n      tempDiv.style.visibility = 'hidden';\n      document.body.appendChild(tempDiv);\n      \n      // Primeiro remover todas as classes de seção\n      SECTIONS.forEach(section => {\n        if (classList.contains(section.className)) {\n          classList.remove(section.className);\n          needsUpdate = true;\n        }\n      });\n      \n      // Depois adicionar apenas a classe ativa\n      if (sectionClass) {\n        classList.add(sectionClass);\n        needsUpdate = true;\n      }\n      \n      // Forçar sincronização de layout apenas se necessário\n      if (needsUpdate) {\n        // Usar um método de baixo custo para forçar sincronização\n        tempDiv.offsetHeight;\n      }\n      \n      // Remover o elemento temporário\n      document.body.removeChild(tempDiv);\n    });\n    \n    // Armazenar o ID do frame para possível cancelamento\n    rafId.current = frameId;\n  }, []);\n\n  // Configurar listeners de forma otimizada com suporte a IntersectionObserver\n  useEffect(() => {\n    // Usar IntersectionObserver para detecção de seção visível\r\n    let observer: IntersectionObserver | null = null;\r\n    \r\n    if ('IntersectionObserver' in window) {\r\n      const observerOptions = {\r\n        root: null,\r\n        rootMargin: '0px',\r\n        threshold: [0.1, 0.3, 0.5, 0.7, 0.9]\r\n      };\r\n      \r\n      let lastVisibleSection: string | null = null;\r\n      \r\n      observer = new IntersectionObserver((entries) => {\r\n        // Encontrar a seção mais visível\r\n        let maxVisibility = 0;\r\n        let mostVisibleSection: string | null = null;\r\n        \r\n        entries.forEach(entry => {\r\n          const sectionElement = entry.target as HTMLElement;\r\n          const sectionId = sectionElement.dataset.section;\r\n          \r\n          if (sectionId && entry.isIntersecting) {\r\n            // Calcular a visibilidade da seção\r\n            const visibility = entry.intersectionRatio;\r\n            \r\n            if (visibility > maxVisibility) {\r\n              maxVisibility = visibility;\r\n              mostVisibleSection = sectionId;\r\n            }\r\n          }\r\n        });\r\n        \r\n        // Atualizar apenas se a seção visível mudou\r\n        if (mostVisibleSection && mostVisibleSection !== lastVisibleSection) {\r\n          lastVisibleSection = mostVisibleSection;\r\n          const section = SECTIONS.find(s => s.id === mostVisibleSection);\r\n          \r\n          if (section) {\r\n            // Usar requestAnimationFrame para agrupar atualizações\r\n            const frameId = requestAnimationFrame(() => {\r\n              setCurrentSection(section.className);\r\n            });\r\n            \r\n            // Armazenar o ID do frame para possível cancelamento\r\n            return () => cancelAnimationFrame(frameId);\r\n          }\r\n        }\r\n      }, observerOptions);\r\n      \r\n      // Registrar observador nas seções\r\n      SECTIONS.forEach(section => {\r\n        const element = document.getElementById(section.id);\r\n        if (element) {\r\n          // Adicionar atributo de dados para identificação\r\n          element.setAttribute('data-section', section.id);\r\n          observer?.observe(element);\r\n        }\r\n      });\r\n    }\r\n    \r\n    // Configurar fallback para navegadores sem suporte a IntersectionObserver\r\n    const debouncedScroll = debounce(handleScroll, 100);\r\n    const scrollOptions = { passive: true, capture: true };\r\n    \r\n    // Usar o evento de scroll apenas como fallback\r\n    const scrollHandler = observer ? () => {} : debouncedScroll;\r\n    \r\n    window.addEventListener('scroll', scrollHandler, scrollOptions);\r\n    \r\n    // Usar requestIdleCallback para atualização inicial\r\n    const init = () => {\r\n      if ('requestIdleCallback' in window) {\r\n        const idleId = (window as any).requestIdleCallback(\r\n          () => {\r\n            const initialSection = detectActiveSection();\r\n            setCurrentSection(initialSection);\r\n          },\r\n          { timeout: 500 }\r\n        );\r\n        \r\n        return () => (window as any).cancelIdleCallback(idleId);\r\n      } else {\r\n        const initialSection = detectActiveSection();\r\n        setCurrentSection(initialSection);\r\n      }\r\n    };\r\n    \r\n    // Inicializar com um pequeno atraso para permitir que o layout seja concluído\r\n    const initTimeout = setTimeout(init, 50);\r\n    \r\n    return () => {\r\n      // Limpar recursos\r\n      clearTimeout(initTimeout);\r\n      observer?.disconnect();\r\n      window.removeEventListener('scroll', scrollHandler, scrollOptions);\r\n      \r\n      if (rafId.current) {\r\n        cancelAnimationFrame(rafId.current);\r\n      }\r\n    };\r\n  }, [handleScroll, detectActiveSection]);\r\n\r\n  // Aplicar classes CSS quando a seção atual mudar\r\n  useEffect(() => {\r\n    applyGradientClass(currentSection);\r\n  }, [currentSection, applyGradientClass]);\r\n\r\n  // Função para forçar mudança de seção (navegação)\r\n  const setSection = useCallback((sectionId: string) => {\r\n    const sectionConfig = SECTIONS.find(s => s.id === sectionId);\r\n    if (sectionConfig) {\r\n      setCurrentSection(sectionConfig.className);\r\n      \r\n      // Usar requestAnimationFrame para garantir que o DOM esteja pronto\r\n      requestAnimationFrame(() => {\r\n        // Rolar suavemente para a seção\r\n        const element = document.getElementById(sectionId);\r\n        if (element) {\r\n          element.scrollIntoView({ behavior: 'smooth' });\r\n        }\r\n      });\r\n    }\r\n  }, []);\r\n\r\n  // Obter informações da seção atual\r\n  const getCurrentSectionInfo = useCallback(() => {\r\n    const config = SECTIONS.find(s => s.className === currentSection);\r\n    return {\r\n      id: config?.id || 'perfil',\r\n      className: currentSection,\r\n      displayName: getSectionDisplayName(config?.id || 'perfil')\r\n    };\r\n  }, [currentSection]);\r\n\r\n  // Memoizar o valor de retorno para evitar recriação desnecessária\r\n  const result = useMemo(() => ({\r\n    currentSection,\r\n    setSection,\r\n    getCurrentSectionInfo,\r\n    isScrolling: false\r\n  }), [currentSection, getCurrentSectionInfo]);\r\n  \r\n  return result;\r\n};\r\n\r\n// Função auxiliar para nomes de exibição\r\nconst getSectionDisplayName = (sectionId: string): string => {\r\n  const names: Record<string, string> = {\r\n    'perfil': 'Perfil',\r\n    'projetos': 'Projetos',\r\n    'backlog': 'Backlog Estratégico',\r\n    'contato': 'Contato'\r\n  };\r\n  return names[sectionId] || sectionId;\r\n};\r\n\r\n// Hook para criar o container de gradiente\r\nexport const useGradientContainer = () => {\r\n  useEffect(() => {\r\n    // Verificar se já existe\r\n    if (document.querySelector('.fluid-gradient-container')) {\r\n      return;\r\n    }\r\n\r\n    // Criar container de gradiente\r\n    const gradientContainer = document.createElement('div');\r\n    gradientContainer.className = 'fluid-gradient-container section-profile';\r\n    \r\n    // Inserir no início do body\r\n    document.body.insertBefore(gradientContainer, document.body.firstChild);\r\n\r\n    // Cleanup\r\n    return () => {\r\n      const container = document.querySelector('.fluid-gradient-container');\r\n      if (container) {\r\n        container.remove();\r\n      }\r\n    };\r\n  }, []);\r\n};\r\n\r\n// Hook combinado para facilitar uso\r\nexport const useFluidGradientSystem = () => {\r\n  useGradientContainer();\r\n  const gradientControls = useFluidGradient();\r\n  \r\n  return gradientControls;\r\n};\r\n\r\n// Função utilitária para transições manuais (navegação)\r\nexport const triggerSectionTransition = (sectionId: string) => {\r\n  const container = document.querySelector('.fluid-gradient-container');\r\n  if (!container) return;\r\n\r\n  const sectionConfig = SECTIONS.find(s => s.id === sectionId);\r\n  if (!sectionConfig) return;\r\n\r\n  // Remover todas as classes\r\n  SECTIONS.forEach(section => {\r\n    container.classList.remove(section.className);\r\n  });\r\n\r\n  // Adicionar nova classe\r\n  container.classList.add(sectionConfig.className);\r\n};\r\n\r\nexport default useFluidGradient;\r\n","import React, { useEffect, useRef, useCallback, useMemo, CSSProperties } from 'react';\r\nimport { useFluidGradientSystem } from '@/hooks/useFluidGradient';\r\n\r\ninterface FluidGradientBackgroundProps {\r\n  children?: React.ReactNode;\r\n  className?: string;\r\n}\r\n\r\n/**\r\n * Componente otimizado que gerencia o sistema de gradientes fluidos\r\n * Utiliza técnicas de otimização para reduzir repaints e melhorar performance\r\n */\r\n// Objeto de estilos estáticos para evitar recriação\r\nconst gradientContainerStyles: CSSProperties = {\r\n  // Forçar aceleração por hardware\r\n  transform: 'translate3d(0, 0, 0)',\r\n  backfaceVisibility: 'hidden',\r\n  perspective: '1000px',\r\n  willChange: 'transform, opacity',\r\n  // Otimizações adicionais\r\n  position: 'fixed',\r\n  top: 0,\r\n  left: 0,\r\n  width: '100%',\r\n  height: '100%',\r\n  zIndex: -1,\r\n  pointerEvents: 'none',\r\n  // Otimização para dispositivos móveis\r\n  WebkitBackfaceVisibility: 'hidden',\r\n  WebkitPerspective: '1000px',\r\n  WebkitTransform: 'translate3d(0, 0, 0)'\r\n};\r\n\r\nconst FluidGradientBackground: React.FC<FluidGradientBackgroundProps> = React.memo(({ \r\n  children, \r\n  className = '' \r\n}) => {\r\n  // Usar refs para armazenar valores que não devem causar re-renderizações\r\n  const lastLogRef = useRef<string>('');\r\n  const containerRef = useRef<HTMLDivElement>(null);\r\n  \r\n  // Inicializar sistema de gradientes\r\n  const { currentSection, getCurrentSectionInfo, setSection } = useFluidGradientSystem();\r\n  \r\n  // Usar useMemo para valores derivados que não mudam frequentemente\r\n  const sectionInfo = useMemo(() => getCurrentSectionInfo(), [getCurrentSectionInfo]);\r\n\r\n  // Debug em desenvolvimento - otimizado para evitar logs desnecessários\r\n  useEffect(() => {\r\n    if (import.meta.env.DEV) {\r\n      const logMessage = `🎨 Fluid Gradient: ${sectionInfo.displayName} (${currentSection})`;\r\n      \r\n      // Só loga se a mensagem for diferente da anterior\r\n      if (logMessage !== lastLogRef.current) {\r\n        console.log(logMessage, {\r\n          section: sectionInfo.displayName,\r\n          className: currentSection,\r\n          timestamp: new Date().toISOString()\r\n        });\r\n        lastLogRef.current = logMessage;\r\n      }\r\n    }\r\n  }, [currentSection, sectionInfo]);\r\n\r\n  // Usar useMemo para o container dos filhos para evitar re-renderizações desnecessárias\r\n  const childrenContainer = useMemo(() => {\r\n    if (!children) return null;\r\n    \r\n    return (\r\n      <div \r\n        className={`relative z-10 ${className}`}\r\n        // Adiciona atributos para melhor acessibilidade e SEO\r\n        role=\"main\"\r\n        aria-live=\"polite\"\r\n        aria-atomic=\"true\"\r\n      >\r\n        {children}\r\n      </div>\r\n    );\r\n  }, [children, className]);\r\n  \r\n  // Efeito para gerenciar a classe do container de gradiente\r\n  useEffect(() => {\r\n    const container = containerRef.current;\r\n    if (!container) return;\r\n    \r\n    // Adiciona a classe da seção atual\r\n    container.className = `fluid-gradient-container ${currentSection}`;\r\n    \r\n    // Força um reflow para garantir que a animação seja suave\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-expressions\r\n    container.offsetHeight;\r\n    \r\n    // Adiciona classe de transição após um pequeno atraso\r\n    const timer = setTimeout(() => {\r\n      container.classList.add('gradient-transition');\r\n    }, 50);\r\n    \r\n    return () => {\r\n      clearTimeout(timer);\r\n      container.classList.remove('gradient-transition');\r\n    };\r\n  }, [currentSection]);\r\n\r\n  return (\r\n    <>\r\n      {/* Container otimizado para gradientes */}\r\n      <div \r\n        ref={containerRef}\r\n        className={`fluid-gradient-container ${currentSection}`}\r\n        style={gradientContainerStyles}\r\n        aria-hidden=\"true\"\r\n        // Adiciona atributos para melhor acessibilidade\r\n        role=\"presentation\"\r\n        aria-label={`Fundo gradiente da seção ${sectionInfo.displayName}`}\r\n      />\r\n      {childrenContainer}\r\n    </>\r\n  );\r\n});\r\n\r\n// Adicionar displayName para melhor debugging\r\nFluidGradientBackground.displayName = 'FluidGradientBackground';\r\n\r\n// Adicionar propriedades estáticas para documentação\r\nif (process.env.NODE_ENV === 'development') {\r\n  // Adicionando propriedade para debug apenas em desenvolvimento\r\n  const WhyDidYouRender = {\r\n    logOnDifferentValues: false,\r\n    trackHooks: true\r\n  };\r\n  \r\n  // @ts-ignore - Propriedade para debug\r\n  FluidGradientBackground.whyDidYouRender = WhyDidYouRender;\r\n}\r\n\r\n/**\r\n * Componente indicador visual da seção atual (opcional)\r\n * Útil para debug ou como indicador de navegação\r\n */\r\n// Componente otimizado para mostrar a seção atual (apenas em desenvolvimento)\r\nexport const GradientSectionIndicator: React.FC = React.memo(() => {\r\n  const { getCurrentSectionInfo } = useFluidGradientSystem();\r\n  \r\n  // Usar useMemo para evitar recálculos desnecessários\r\n  const sectionInfo = useMemo(() => getCurrentSectionInfo(), [getCurrentSectionInfo]);\r\n\r\n  // Não renderizar em produção\r\n  if (import.meta.env.PROD) {\r\n    return null;\r\n  }\r\n\r\n  return (\r\n    <div \r\n      className=\"fixed top-20 right-4 z-50 bg-black/80 text-white px-3 py-2 rounded-lg text-sm font-mono backdrop-blur-sm\"\r\n      style={{\r\n        // Otimizações para melhor desempenho\r\n        willChange: 'transform, opacity',\r\n        transform: 'translateZ(0)',\r\n        WebkitTransform: 'translateZ(0)'\r\n      }}\r\n    >\r\n      <div className=\"text-xs opacity-70\">Seção Atual:</div>\r\n      <div className=\"font-semibold\">{sectionInfo.displayName}</div>\r\n      <div className=\"text-xs opacity-50\">{sectionInfo.className}</div>\r\n      <div className=\"mt-1 pt-1 border-t border-white/10 text-2xs opacity-50\">\r\n        {new Date().toLocaleTimeString()}\r\n      </div>\r\n    </div>\r\n  );\r\n});\r\n\r\n// Adicionar displayName para melhor debugging\r\nGradientSectionIndicator.displayName = 'GradientSectionIndicator';\r\n\r\n/**\r\n * Hook para componentes que precisam reagir às mudanças de seção\r\n */\r\n// Hook otimizado para acessar informações da seção atual\r\nexport const useCurrentSection = () => {\r\n  const { getCurrentSectionInfo } = useFluidGradientSystem();\r\n  \r\n  // Usar useMemo para evitar recálculos desnecessários\r\n  return useMemo(() => getCurrentSectionInfo(), [getCurrentSectionInfo]);\r\n};\r\n\r\n// Tipos das seções disponíveis\r\ntype SectionId = 'perfil' | 'projetos' | 'backlog' | 'contato';\r\n\r\n/**\r\n * Componente wrapper para seções que precisam de gradientes específicos\r\n */\r\ninterface GradientSectionProps {\r\n  sectionId: SectionId;\r\n  children: React.ReactNode;\r\n  className?: string;\r\n}\r\n\r\n// Componente wrapper otimizado para seções com gradientes específicos\r\nexport const GradientSection: React.FC<GradientSectionProps> = React.memo(({\r\n  sectionId,\r\n  children,\r\n  className = ''\r\n}) => {\r\n  return (\r\n    <section \r\n      id={sectionId}\r\n      className={`relative ${className}`}\r\n      data-gradient-section={sectionId}\r\n    >\r\n      {children}\r\n    </section>\r\n  );\r\n});\r\n\r\n/**\r\n * Componente para transições manuais de gradiente\r\n * Útil para navegação ou botões que mudam seção\r\n */\r\ninterface GradientTriggerProps {\r\n  targetSection: SectionId;\r\n  children: React.ReactNode;\r\n  className?: string;\r\n  onClick?: () => void;\r\n}\r\n\r\n// Componente otimizado para disparar mudanças de gradiente\r\nexport const GradientTrigger: React.FC<GradientTriggerProps> = React.memo(({\r\n  targetSection,\r\n  children,\r\n  className = '',\r\n  onClick\r\n}) => {\r\n  const { setSection } = useFluidGradientSystem();\r\n\r\n  const handleClick = useCallback((e: React.MouseEvent | React.KeyboardEvent) => {\r\n    e.preventDefault();\r\n    setSection(targetSection);\r\n    if (onClick) {\r\n      onClick();\r\n    }\r\n  }, [setSection, targetSection, onClick]);\r\n\r\n  const handleKeyDown = useCallback((e: React.KeyboardEvent) => {\r\n    if (e.key === 'Enter' || e.key === ' ') {\r\n      handleClick(e);\r\n    }\r\n  }, [handleClick]);\r\n\r\n  return (\r\n    <div \r\n      className={`cursor-pointer ${className}`}\r\n      onClick={handleClick}\r\n      role=\"button\"\r\n      tabIndex={0}\r\n      onKeyDown={handleKeyDown}\r\n      aria-label={`Ir para a seção ${targetSection}`}\r\n    >\r\n      {children}\r\n    </div>\r\n  );\r\n});\r\n\r\nexport default FluidGradientBackground;\r\n"],"names":["SECTIONS","id","className","threshold","sectionElementsCache","Map","useFluidGradient","currentSection","setCurrentSection","useState","sectionsRef","useRef","rafId","lastScrollY","window","scrollY","ticking","lastSectionChange","useLayoutEffect","getSectionElement","has","get","element","document","getElementById","set","current","map","section","top","height","updateDims","requestIdleCallback","updateSectionDimensions","timeout","resizeTimeout","handleResize","setTimeout","clear","addEventListener","passive","removeEventListener","cancelAnimationFrame","useCallback","length","requestAnimationFrame","tempDiv","createElement","style","position","visibility","body","appendChild","viewportHeight","innerHeight","newSections","hasChanges","forEach","push","rect","getBoundingClientRect","isInView","bottom","Math","abs","removeChild","detectActiveSection","now","Date","windowHeight","viewportMiddle","elementAtCenter","elementFromPoint","innerWidth","sectionElement","closest","dataset","sectionId","find","s","closestSection","minDistance","Infinity","elementCenter","viewportCenter","distance","handleScroll","frameId","newSection","applyGradientClass","sectionClass","container","querySelector","classList","currentActive","contains","remove","add","useEffect","observer","lastVisibleSection","IntersectionObserver","entries","maxVisibility","mostVisibleSection","entry","target","isIntersecting","intersectionRatio","root","rootMargin","setAttribute","observe","debouncedScroll","func","wait","args","debounce","scrollOptions","capture","scrollHandler","initTimeout","idleId","initialSection","cancelIdleCallback","clearTimeout","disconnect","setSection","sectionConfig","scrollIntoView","behavior","getCurrentSectionInfo","config","displayName","getSectionDisplayName","result","useMemo","isScrolling","perfil","projetos","backlog","contato","useFluidGradientSystem","gradientContainer","insertBefore","firstChild","gradientControls","gradientContainerStyles","transform","backfaceVisibility","perspective","willChange","left","width","zIndex","pointerEvents","WebkitBackfaceVisibility","WebkitPerspective","WebkitTransform","FluidGradientBackground","memo","children","containerRef","sectionInfo","childrenContainer","div","role","aria-live","aria-atomic","timer","_Fragment","ref","aria-hidden","aria-label","GradientSectionIndicator","useCurrentSection","GradientSection","data-gradient-section","GradientTrigger","targetSection","onClick","handleClick","e","preventDefault","handleKeyDown","key","tabIndex","onKeyDown"],"mappings":"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"}